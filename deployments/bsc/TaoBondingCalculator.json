{
  "address": "0x10151C93204a24463732Ba2391f8996313f9acaF",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "k_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountDeposited_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalSupplyOfTokenDeposited_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "pendingDebtDue_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "managedTokenTotalSupply_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "bondScalingValue_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "interestDue_",
          "type": "uint256"
        }
      ],
      "name": "BondInterest",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "debtRatio_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "bondScalingValue_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "premium_",
          "type": "uint256"
        }
      ],
      "name": "BondPremium",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "k_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountDeposited_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalSupplyOfTokenDeposited_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "principleValuation_",
          "type": "uint256"
        }
      ],
      "name": "PrincipleValuation",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "debtRatio_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bondScalingValue_",
          "type": "uint256"
        }
      ],
      "name": "calcBondPremium",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "premium_",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "pendingDebtDue_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "managedTokenTotalSupply_",
          "type": "uint256"
        }
      ],
      "name": "calcDebtRatio",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "debtRatio_",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "k_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountDeposited_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalSupplyOfTokenDeposited_",
          "type": "uint256"
        }
      ],
      "name": "calcPrincipleValuation",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "principleValuation_",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "treasury_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "principleTokenAddress_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountDeposited_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bondScalingValue_",
          "type": "uint256"
        }
      ],
      "name": "calculateBondInterest",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "interestDue_",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "principleTokenAddress_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountDeposited_",
          "type": "uint256"
        }
      ],
      "name": "principleValuation",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "principleValuation_",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x85d830d35923d8c7ee61e03a972fbc258f50dafb7c9d8eb2bcbe3e40a0acfd74",
  "receipt": {
    "to": null,
    "from": "0xcc77159E0C7ca174672a84794Dfed8AA2E52c072",
    "contractAddress": "0x10151C93204a24463732Ba2391f8996313f9acaF",
    "transactionIndex": 94,
    "gasUsed": "675185",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xeb9d8328f6e30cd2777b8339d8e6c3e4f8bb36f4252cc06bcff33012274572ae",
    "transactionHash": "0x85d830d35923d8c7ee61e03a972fbc258f50dafb7c9d8eb2bcbe3e40a0acfd74",
    "logs": [],
    "blockNumber": 7068858,
    "cumulativeGasUsed": "21085503",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "a608473174dba90444465c62f045a20c",
  "metadata": "{\"compiler\":{\"version\":\"0.7.5+commit.eb77ed08\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"k_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDeposited_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupplyOfTokenDeposited_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pendingDebtDue_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"managedTokenTotalSupply_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondScalingValue_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestDue_\",\"type\":\"uint256\"}],\"name\":\"BondInterest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtRatio_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondScalingValue_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"premium_\",\"type\":\"uint256\"}],\"name\":\"BondPremium\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"k_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDeposited_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupplyOfTokenDeposited_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"principleValuation_\",\"type\":\"uint256\"}],\"name\":\"PrincipleValuation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"debtRatio_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bondScalingValue_\",\"type\":\"uint256\"}],\"name\":\"calcBondPremium\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"premium_\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pendingDebtDue_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"managedTokenTotalSupply_\",\"type\":\"uint256\"}],\"name\":\"calcDebtRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"debtRatio_\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"k_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountDeposited_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupplyOfTokenDeposited_\",\"type\":\"uint256\"}],\"name\":\"calcPrincipleValuation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principleValuation_\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principleTokenAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountDeposited_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bondScalingValue_\",\"type\":\"uint256\"}],\"name\":\"calculateBondInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"interestDue_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"principleTokenAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountDeposited_\",\"type\":\"uint256\"}],\"name\":\"principleValuation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principleValuation_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Bonding/TaoBondingCalculator.sol\":\"TaoBondingCalculator\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Bonding/TaoBondingCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\ninterface IUniswapV2ERC20 {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair is IUniswapV2ERC20 {\\r\\n    // event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    // event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n\\r\\n    // function name() external pure returns (string memory);\\r\\n    // function symbol() external pure returns (string memory);\\r\\n    // function decimals() external pure returns (uint8);\\r\\n    // function totalSupply() external view returns (uint);\\r\\n    // function balanceOf(address owner) external view returns (uint);\\r\\n    // function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    // function approve(address spender, uint value) external returns (bool);\\r\\n    // function transfer(address to, uint value) external returns (bool);\\r\\n    // function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    // function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    // function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    // function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    // function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\\r\\nlibrary FullMath {\\r\\n    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\\r\\n        uint256 mm = mulmod(x, y, uint256(-1));\\r\\n        l = x * y;\\r\\n        h = mm - l;\\r\\n        if (mm < l) h -= 1;\\r\\n    }\\r\\n\\r\\n    function fullDiv(\\r\\n        uint256 l,\\r\\n        uint256 h,\\r\\n        uint256 d\\r\\n    ) private pure returns (uint256) {\\r\\n        uint256 pow2 = d & -d;\\r\\n        d /= pow2;\\r\\n        l /= pow2;\\r\\n        l += h * ((-pow2) / pow2 + 1);\\r\\n        uint256 r = 1;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        return l * r;\\r\\n    }\\r\\n\\r\\n    function mulDiv(\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        uint256 d\\r\\n    ) internal pure returns (uint256) {\\r\\n        (uint256 l, uint256 h) = fullMul(x, y);\\r\\n        uint256 mm = mulmod(x, y, d);\\r\\n        if (mm > l) h -= 1;\\r\\n        l -= mm;\\r\\n        require(h < d, 'FullMath::mulDiv: overflow');\\r\\n        return fullDiv(l, h, d);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary Babylonian {\\r\\n    // credit for this implementation goes to\\r\\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\\r\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\r\\n        if (x == 0) return 0;\\r\\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\\r\\n        // however that code costs significantly more gas\\r\\n        uint256 xx = x;\\r\\n        uint256 r = 1;\\r\\n        if (xx >= 0x100000000000000000000000000000000) {\\r\\n            xx >>= 128;\\r\\n            r <<= 64;\\r\\n        }\\r\\n        if (xx >= 0x10000000000000000) {\\r\\n            xx >>= 64;\\r\\n            r <<= 32;\\r\\n        }\\r\\n        if (xx >= 0x100000000) {\\r\\n            xx >>= 32;\\r\\n            r <<= 16;\\r\\n        }\\r\\n        if (xx >= 0x10000) {\\r\\n            xx >>= 16;\\r\\n            r <<= 8;\\r\\n        }\\r\\n        if (xx >= 0x100) {\\r\\n            xx >>= 8;\\r\\n            r <<= 4;\\r\\n        }\\r\\n        if (xx >= 0x10) {\\r\\n            xx >>= 4;\\r\\n            r <<= 2;\\r\\n        }\\r\\n        if (xx >= 0x8) {\\r\\n            r <<= 1;\\r\\n        }\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\r\\n        uint256 r1 = x / r;\\r\\n        return (r < r1 ? r : r1);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary BitMath {\\r\\n    // returns the 0 indexed position of the most significant bit of the input x\\r\\n    // s.t. x >= 2**msb and x < 2**(msb+1)\\r\\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\\r\\n        require(x > 0, 'BitMath::mostSignificantBit: zero');\\r\\n\\r\\n        if (x >= 0x100000000000000000000000000000000) {\\r\\n            x >>= 128;\\r\\n            r += 128;\\r\\n        }\\r\\n        if (x >= 0x10000000000000000) {\\r\\n            x >>= 64;\\r\\n            r += 64;\\r\\n        }\\r\\n        if (x >= 0x100000000) {\\r\\n            x >>= 32;\\r\\n            r += 32;\\r\\n        }\\r\\n        if (x >= 0x10000) {\\r\\n            x >>= 16;\\r\\n            r += 16;\\r\\n        }\\r\\n        if (x >= 0x100) {\\r\\n            x >>= 8;\\r\\n            r += 8;\\r\\n        }\\r\\n        if (x >= 0x10) {\\r\\n            x >>= 4;\\r\\n            r += 4;\\r\\n        }\\r\\n        if (x >= 0x4) {\\r\\n            x >>= 2;\\r\\n            r += 2;\\r\\n        }\\r\\n        if (x >= 0x2) r += 1;\\r\\n    }\\r\\n\\r\\n    // returns the 0 indexed position of the least significant bit of the input x\\r\\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\\r\\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\\r\\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\\r\\n        require(x > 0, 'BitMath::leastSignificantBit: zero');\\r\\n\\r\\n        r = 255;\\r\\n        if (x & uint128(-1) > 0) {\\r\\n            r -= 128;\\r\\n        } else {\\r\\n            x >>= 128;\\r\\n        }\\r\\n        if (x & uint64(-1) > 0) {\\r\\n            r -= 64;\\r\\n        } else {\\r\\n            x >>= 64;\\r\\n        }\\r\\n        if (x & uint32(-1) > 0) {\\r\\n            r -= 32;\\r\\n        } else {\\r\\n            x >>= 32;\\r\\n        }\\r\\n        if (x & uint16(-1) > 0) {\\r\\n            r -= 16;\\r\\n        } else {\\r\\n            x >>= 16;\\r\\n        }\\r\\n        if (x & uint8(-1) > 0) {\\r\\n            r -= 8;\\r\\n        } else {\\r\\n            x >>= 8;\\r\\n        }\\r\\n        if (x & 0xf > 0) {\\r\\n            r -= 4;\\r\\n        } else {\\r\\n            x >>= 4;\\r\\n        }\\r\\n        if (x & 0x3 > 0) {\\r\\n            r -= 2;\\r\\n        } else {\\r\\n            x >>= 2;\\r\\n        }\\r\\n        if (x & 0x1 > 0) r -= 1;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary FixedPoint {\\r\\n    // range: [0, 2**112 - 1]\\r\\n    // resolution: 1 / 2**112\\r\\n    struct uq112x112 {\\r\\n        uint224 _x;\\r\\n    }\\r\\n\\r\\n    // range: [0, 2**144 - 1]\\r\\n    // resolution: 1 / 2**112\\r\\n    struct uq144x112 {\\r\\n        uint256 _x;\\r\\n    }\\r\\n\\r\\n    uint8 private constant RESOLUTION = 112;\\r\\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\\r\\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\\r\\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\\r\\n\\r\\n    // encode a uint112 as a UQ112x112\\r\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\r\\n        return uq112x112(uint224(x) << RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // encodes a uint144 as a UQ144x112\\r\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\r\\n        return uq144x112(uint256(x) << RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\r\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\r\\n        return uint112(self._x >> RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\r\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\r\\n        return uint144(self._x >> RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // decode a uq112x112 into a uint with 18 decimals of precision\\r\\n  function decode112with18(uq112x112 memory self) internal pure returns (uint) {\\r\\n    // we only have 256 - 224 = 32 bits to spare, so scaling up by ~60 bits is dangerous\\r\\n    // instead, get close to:\\r\\n    //  (x * 1e18) >> 112\\r\\n    // without risk of overflowing, e.g.:\\r\\n    //  (x) / 2 ** (112 - lg(1e18))\\r\\n    return uint(self._x) / 5192296858534827;\\r\\n  }\\r\\n\\r\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\r\\n    // reverts on overflow\\r\\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\\r\\n        uint256 z = 0;\\r\\n        require(y == 0 || (z = self._x * y) / y == self._x, 'FixedPoint::mul: overflow');\\r\\n        return uq144x112(z);\\r\\n    }\\r\\n\\r\\n    // multiply a UQ112x112 by an int and decode, returning an int\\r\\n    // reverts on overflow\\r\\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\\r\\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\\r\\n        require(z < 2**255, 'FixedPoint::muli: overflow');\\r\\n        return y < 0 ? -int256(z) : int256(z);\\r\\n    }\\r\\n\\r\\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\\r\\n    // lossy\\r\\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\\r\\n        if (self._x == 0 || other._x == 0) {\\r\\n            return uq112x112(0);\\r\\n        }\\r\\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\\r\\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\\r\\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\\r\\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\\r\\n\\r\\n        // partial products\\r\\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\\r\\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\\r\\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\\r\\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\\r\\n\\r\\n        // so the bit shift does not overflow\\r\\n        require(upper <= uint112(-1), 'FixedPoint::muluq: upper overflow');\\r\\n\\r\\n        // this cannot exceed 256 bits, all values are 224 bits\\r\\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\\r\\n\\r\\n        // so the cast does not overflow\\r\\n        require(sum <= uint224(-1), 'FixedPoint::muluq: sum overflow');\\r\\n\\r\\n        return uq112x112(uint224(sum));\\r\\n    }\\r\\n\\r\\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\\r\\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\\r\\n        require(other._x > 0, 'FixedPoint::divuq: division by zero');\\r\\n        if (self._x == other._x) {\\r\\n            return uq112x112(uint224(Q112));\\r\\n        }\\r\\n        if (self._x <= uint144(-1)) {\\r\\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\\r\\n            require(value <= uint224(-1), 'FixedPoint::divuq: overflow');\\r\\n            return uq112x112(uint224(value));\\r\\n        }\\r\\n\\r\\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\\r\\n        require(result <= uint224(-1), 'FixedPoint::divuq: overflow');\\r\\n        return uq112x112(uint224(result));\\r\\n    }\\r\\n\\r\\n  // returns a uq112x112 which represents the ratio of the numerator to the denominator\\r\\n  // equivalent to encode(numerator).div(denominator)\\r\\n  // function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\r\\n  //   require(denominator > 0, \\\"DIV_BY_ZERO\\\");\\r\\n  //   return uq112x112((uint224(numerator) << 112) / denominator);\\r\\n  // }\\r\\n\\r\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\r\\n    // lossy if either numerator or denominator is greater than 112 bits\\r\\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\\r\\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\\r\\n        if (numerator == 0) return FixedPoint.uq112x112(0);\\r\\n\\r\\n        if (numerator <= uint144(-1)) {\\r\\n            uint256 result = (numerator << RESOLUTION) / denominator;\\r\\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\\r\\n            return uq112x112(uint224(result));\\r\\n        } else {\\r\\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\\r\\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\\r\\n            return uq112x112(uint224(result));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // take the reciprocal of a UQ112x112\\r\\n    // reverts on overflow\\r\\n    // lossy\\r\\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\r\\n        require(self._x != 0, 'FixedPoint::reciprocal: reciprocal of zero');\\r\\n        require(self._x != 1, 'FixedPoint::reciprocal: overflow');\\r\\n        return uq112x112(uint224(Q224 / self._x));\\r\\n    }\\r\\n\\r\\n    // square root of a UQ112x112\\r\\n    // lossy between 0/1 and 40 bits\\r\\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\r\\n        if (self._x <= uint144(-1)) {\\r\\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\\r\\n        }\\r\\n\\r\\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\\r\\n        safeShiftBits -= safeShiftBits % 2;\\r\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\r\\n    function sqrrt(uint256 a) internal pure returns (uint c) {\\r\\n        if (a > 3) {\\r\\n            c = a;\\r\\n            uint b = add( div( a, 2), 1 );\\r\\n            while (b < c) {\\r\\n                c = b;\\r\\n                b = div( add( div( a, b ), b), 2 );\\r\\n            }\\r\\n        } else if (a != 0) {\\r\\n            c = 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Expects percentage to be trailed by 00,\\r\\n    */\\r\\n    function percentageAmount( uint256 total_, uint8 percentage_ ) internal pure returns ( uint256 percentAmount_ ) {\\r\\n        return div( mul( total_, percentage_ ), 1000 );\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Expects percentage to be trailed by 00,\\r\\n    */\\r\\n    function substractPercentage( uint256 total_, uint8 percentageToSub_ ) internal pure returns ( uint256 result_ ) {\\r\\n        return sub( total_, div( mul( total_, percentageToSub_ ), 1000 ) );\\r\\n    }\\r\\n\\r\\n    function percentageOfTotal( uint256 part_, uint256 total_ ) internal pure returns ( uint256 percent_ ) {\\r\\n        return div( mul(part_, 100) , total_ );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Taken from Hypersonic https://github.com/M2629/HyperSonic/blob/main/Math.sol\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\r\\n    }\\r\\n\\r\\n    function quadraticPricing( uint256 payment_, uint256 multiplier_ ) internal pure returns (uint256) {\\r\\n        return sqrrt( mul( multiplier_, payment_ ) );\\r\\n    }\\r\\n\\r\\n  function bondingCurve( uint256 supply_, uint256 multiplier_ ) internal pure returns (uint256) {\\r\\n      return mul( multiplier_, supply_ );\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface ITreasury {\\r\\n\\r\\n  function getBondingCalculator() external returns ( address );\\r\\n  function payDebt( address depositor_ ) external returns ( bool );\\r\\n  function getTimelockEndBlock() external returns ( uint );\\r\\n  function getManagedToken() external returns ( address );\\r\\n  function getDebtAmountDue() external returns ( uint );\\r\\n  function incurDebt( uint principieTokenAmountDeposited_, uint bondScalingValue_ ) external returns ( bool );\\r\\n}\\r\\n\\r\\ninterface IBondingCalculator {\\r\\n\\r\\n  function calcDebtRatio( uint pendingDebtDue_, uint managedTokenTotalSupply_ ) external pure returns ( uint debtRatio_ );\\r\\n\\r\\n  function calcBondPremium( uint debtRatio_, uint bondScalingFactor ) external pure returns ( uint premium_ );\\r\\n\\r\\n  function calcPrincipleValuation( uint k_, uint amountDeposited_, uint totalSupplyOfTokenDeposited_ ) external pure returns ( uint principleValuation_ );\\r\\n\\r\\n  function principleValuation( address principleTokenAddress_, uint amountDeposited_ ) external view returns ( uint principleValuation_ );\\r\\n\\r\\n  function calculateBondInterest( address treasury_, address principleTokenAddress_, uint amountDeposited_, uint bondScalingFactor ) external returns ( uint interestDue_ );\\r\\n}\\r\\n\\r\\ncontract TaoBondingCalculator is IBondingCalculator {\\r\\n\\r\\n  using FixedPoint for *;\\r\\n  using SafeMath for uint;\\r\\n  using SafeMath for uint112;\\r\\n\\r\\n  event BondPremium( uint debtRatio_, uint bondScalingValue_, uint premium_ );\\r\\n  event PrincipleValuation( uint k_, uint amountDeposited_, uint totalSupplyOfTokenDeposited_, uint principleValuation_  );\\r\\n  event BondInterest( uint k_, uint amountDeposited_, uint totalSupplyOfTokenDeposited_, uint pendingDebtDue_, uint managedTokenTotalSupply_, uint bondScalingValue_, uint interestDue_ );\\r\\n\\r\\n  function _calcDebtRatio( uint pendingDebtDue_, uint managedTokenTotalSupply_ ) internal pure returns ( uint debtRatio_ ) {\\r\\n    debtRatio_ = FixedPoint.fraction(\\r\\n      // Must move the decimal to the right by 9 places to avoid math underflow error\\r\\n      pendingDebtDue_.mul( 1e9 ),\\r\\n      managedTokenTotalSupply_\\r\\n    ).decode112with18()\\r\\n    // Must move the decimal tot he left 18 places to account for the 9 places added above and the 19 signnificant digits added by FixedPoint.\\r\\n    .div(1e18);\\r\\n\\r\\n  }\\r\\n\\r\\n  function calcDebtRatio( uint pendingDebtDue_, uint managedTokenTotalSupply_ ) external pure override returns ( uint debtRatio_ ) {\\r\\n    debtRatio_ = _calcDebtRatio( pendingDebtDue_, managedTokenTotalSupply_ );\\r\\n  }\\r\\n\\r\\n  // Premium is 2 extra deciamls i.e. 250 = 2.5 premium\\r\\n  function _calcBondPremium( uint debtRatio_, uint bondScalingValue_ ) internal pure returns ( uint premium_ ) {\\r\\n    // premium_ = uint( uint(1).mul( 1e9 ).add( debtRatio_ ) ** bondScalingValue_);\\r\\n    premium_ = bondScalingValue_.mul( (debtRatio_) ).add( uint(1010000000) ).div( 1e7 );\\r\\n  }\\r\\n\\r\\n  function calcBondPremium( uint debtRatio_, uint bondScalingValue_ ) external pure override returns ( uint premium_ ) {\\r\\n    premium_ = _calcBondPremium( debtRatio_, bondScalingValue_ );\\r\\n  }\\r\\n\\r\\n  function _principleValuation( uint k_, uint amountDeposited_, uint totalSupplyOfTokenDeposited_ ) internal pure returns ( uint principleValuation_ ) {\\r\\n    // *** When deposit amount is small does not pick up principle valuation *** \\\\\\\\\\r\\n    principleValuation_ = k_.sqrrt().mul(2).mul( FixedPoint.fraction( amountDeposited_, totalSupplyOfTokenDeposited_ ).decode112with18().div( 1e10 ).mul( 10 ) );\\r\\n  }\\r\\n\\r\\n  function calcPrincipleValuation( uint k_, uint amountDeposited_, uint totalSupplyOfTokenDeposited_ ) external pure override returns ( uint principleValuation_ ) {\\r\\n    principleValuation_ = _principleValuation( k_, amountDeposited_, totalSupplyOfTokenDeposited_ );\\r\\n  }\\r\\n\\r\\n  function principleValuation( address principleTokenAddress_, uint amountDeposited_ ) external view override returns ( uint principleValuation_ ) {\\r\\n    uint k_ = _getKValue(principleTokenAddress_);\\r\\n\\r\\n    uint principleTokenTotalSupply_ = IUniswapV2Pair( principleTokenAddress_ ).totalSupply();\\r\\n    principleValuation_ = _principleValuation( k_, amountDeposited_, principleTokenTotalSupply_ );\\r\\n  }\\r\\n\\r\\n  function _calculateBondInterest( uint k_, uint amountDeposited_, uint totalSupplyOfTokenDeposited_, uint pendingDebtDue_, uint managedTokenTotalSupply_, uint bondScalingValue_ ) internal returns ( uint interestDue_ ) {\\r\\n    uint principleValuation_ = _principleValuation( k_, amountDeposited_, totalSupplyOfTokenDeposited_ );\\r\\n\\r\\n    uint debtRatio_ = _calcDebtRatio( pendingDebtDue_, managedTokenTotalSupply_ );\\r\\n\\r\\n    uint premium_ = _calcBondPremium( debtRatio_, bondScalingValue_ );\\r\\n\\r\\n    interestDue_ = FixedPoint.fraction(\\r\\n      principleValuation_,\\r\\n     premium_\\r\\n    ).decode().div( 100 );\\r\\n    emit BondInterest( k_, amountDeposited_, totalSupplyOfTokenDeposited_, pendingDebtDue_, managedTokenTotalSupply_, bondScalingValue_, interestDue_ );\\r\\n  }\\r\\n\\r\\n\\r\\n  function calculateBondInterest( address treasury_, address principleTokenAddress_, uint amountDeposited_, uint bondScalingValue_ ) external override returns ( uint interestDue_ ) {\\r\\n    //uint k_ = IUniswapV2Pair( principleTokenAddress_ ).kLast();\\r\\n\\r\\n    uint k_ = _getKValue(principleTokenAddress_);\\r\\n\\r\\n    uint principleTokenTotalSuply_ = IUniswapV2Pair( principleTokenAddress_ ).totalSupply();\\r\\n\\r\\n    address managedToken_ = ITreasury( treasury_ ).getManagedToken();\\r\\n\\r\\n    uint managedTokenTotalSuply_ = IUniswapV2Pair( managedToken_ ).totalSupply();\\r\\n\\r\\n    uint outstandingDebtAmount_ = ITreasury( treasury_ ).getDebtAmountDue();\\r\\n\\r\\n    interestDue_ = _calculateBondInterest( k_, amountDeposited_, principleTokenTotalSuply_, outstandingDebtAmount_, managedTokenTotalSuply_, bondScalingValue_ );\\r\\n  }\\r\\n\\r\\n  function _getKValue( address principleTokenAddress_ ) internal view returns( uint k_ )  {\\r\\n    (uint reserve0, uint reserve1, ) = IUniswapV2Pair( principleTokenAddress_ ).getReserves();\\r\\n     k_ = reserve0.mul(reserve1).div(1e9);\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0x029f0cb37b18fcb04328e2c819690d7f0514ada2391938a483987fc6e672d673\",\"license\":\"AGPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610b42806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80630221e7161461005c5780636be06f14146100915780636c9c7cb6146100b4578063f1ee451d146100dd578063fb452dc114610119575b600080fd5b61007f6004803603604081101561007257600080fd5b5080359060200135610145565b60408051918252519081900360200190f35b61007f600480360360408110156100a757600080fd5b5080359060200135610158565b61007f600480360360608110156100ca57600080fd5b5080359060208101359060400135610164565b61007f600480360360808110156100f357600080fd5b506001600160a01b03813581169160208101359091169060408101359060600135610179565b61007f6004803603604081101561012f57600080fd5b506001600160a01b038135169060200135610364565b600061015183836103ef565b9392505050565b60006101518383610416565b6000610171848484610443565b949350505050565b60008061018585610477565b90506000856001600160a01b03166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b1580156101c257600080fd5b505afa1580156101d6573d6000803e3d6000fd5b505050506040513d60208110156101ec57600080fd5b5051604080516376f9fa3d60e01b815290519192506000916001600160a01b038a16916376f9fa3d91600480830192602092919082900301818787803b15801561023557600080fd5b505af1158015610249573d6000803e3d6000fd5b505050506040513d602081101561025f57600080fd5b5051604080516318160ddd60e01b815290519192506000916001600160a01b038416916318160ddd916004808301926020929190829003018186803b1580156102a757600080fd5b505afa1580156102bb573d6000803e3d6000fd5b505050506040513d60208110156102d157600080fd5b505160408051631c2e50c160e11b815290519192506000916001600160a01b038c169163385ca18291600480830192602092919082900301818787803b15801561031a57600080fd5b505af115801561032e573d6000803e3d6000fd5b505050506040513d602081101561034457600080fd5b5051905061035685898684868c61050a565b9a9950505050505050505050565b60008061037084610477565b90506000846001600160a01b03166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b1580156103ad57600080fd5b505afa1580156103c1573d6000803e3d6000fd5b505050506040513d60208110156103d757600080fd5b505190506103e6828583610443565b95945050505050565b600061015162989680610410633c33608061040a86886105c9565b9061062b565b90610685565b6000610151670de0b6b3a764000061041061043e61043887633b9aca006105c9565b866106c7565b61083e565b6000610171610469600a6104636402540be40061041061043e89896106c7565b906105c9565b61046360026104638861085a565b6000806000836001600160a01b0316630902f1ac6040518163ffffffff1660e01b815260040160606040518083038186803b1580156104b557600080fd5b505afa1580156104c9573d6000803e3d6000fd5b505050506040513d60608110156104df57600080fd5b5080516020909101516001600160701b039182169350169050610171633b9aca0061041084846105c9565b600080610518888888610443565b905060006105268686610416565b9050600061053482866103ef565b905061055c606461054d61054886856106c7565b6108c4565b6001600160701b031690610685565b604080518c8152602081018c90528082018b9052606081018a90526080810189905260a0810188905260c0810183905290519195507f3a269f8b7a14b50e5e96327a1e2888aa70caf27d3fe04d3d47b401e8e78489e1919081900360e00190a15050509695505050505050565b6000826105d857506000610625565b828202828482816105e557fe5b04146106225760405162461bcd60e51b8152600401808060200182810382526021815260200180610aec6021913960400191505060405180910390fd5b90505b92915050565b600082820183811015610622576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b600061015183836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f0000000000008152506108d4565b6106cf610ab3565b6000821161070e5760405162461bcd60e51b8152600401808060200182810382526026815260200180610ac66026913960400191505060405180910390fd5b826107285750604080516020810190915260008152610625565b71ffffffffffffffffffffffffffffffffffff83116107cf57600082607085901b8161075057fe5b0490506001600160e01b038111156107af576040805162461bcd60e51b815260206004820152601e60248201527f4669786564506f696e743a3a6672616374696f6e3a206f766572666c6f770000604482015290519081900360640190fd5b6040518060200160405280826001600160e01b0316815250915050610625565b60006107e084600160701b85610976565b90506001600160e01b038111156107af576040805162461bcd60e51b815260206004820152601e60248201527f4669786564506f696e743a3a6672616374696f6e3a206f766572666c6f770000604482015290519081900360640190fd5b80516612725dd1d243ab6001600160e01b03909116045b919050565b600060038211156108b6575080600061087e610877836002610685565b600161062b565b90505b818110156108b0578091506108a96108a261089c8584610685565b8361062b565b6002610685565b9050610881565b50610855565b811561085557506001919050565b5160701c6001600160701b031690565b600081836109605760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561092557818101518382015260200161090d565b50505050905090810190601f1680156109525780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b50600083858161096c57fe5b0495945050505050565b60008060006109858686610a16565b915091506000848061099357fe5b8688099050828111156109a7576001820391505b8083039250848210610a00576040805162461bcd60e51b815260206004820152601a60248201527f46756c6c4d6174683a3a6d756c4469763a206f766572666c6f77000000000000604482015290519081900360640190fd5b610a0b838387610a43565b979650505050505050565b6000808060001984860990508385029250828103915082811015610a3b576001820391505b509250929050565b60008181038216808381610a5357fe5b049250808581610a5f57fe5b049450808160000381610a6e57fe5b60028581038087028203028087028203028087028203028087028203028087028203028087028203029586029003909402930460010193909302939093010292915050565b6040805160208101909152600081529056fe4669786564506f696e743a3a6672616374696f6e3a206469766973696f6e206279207a65726f536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f77a26469706673582212208b2e3f9370b97bdd0d2b90b7d0b10fee844ca7b3b277762a7136f40d31914d3064736f6c63430007050033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c80630221e7161461005c5780636be06f14146100915780636c9c7cb6146100b4578063f1ee451d146100dd578063fb452dc114610119575b600080fd5b61007f6004803603604081101561007257600080fd5b5080359060200135610145565b60408051918252519081900360200190f35b61007f600480360360408110156100a757600080fd5b5080359060200135610158565b61007f600480360360608110156100ca57600080fd5b5080359060208101359060400135610164565b61007f600480360360808110156100f357600080fd5b506001600160a01b03813581169160208101359091169060408101359060600135610179565b61007f6004803603604081101561012f57600080fd5b506001600160a01b038135169060200135610364565b600061015183836103ef565b9392505050565b60006101518383610416565b6000610171848484610443565b949350505050565b60008061018585610477565b90506000856001600160a01b03166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b1580156101c257600080fd5b505afa1580156101d6573d6000803e3d6000fd5b505050506040513d60208110156101ec57600080fd5b5051604080516376f9fa3d60e01b815290519192506000916001600160a01b038a16916376f9fa3d91600480830192602092919082900301818787803b15801561023557600080fd5b505af1158015610249573d6000803e3d6000fd5b505050506040513d602081101561025f57600080fd5b5051604080516318160ddd60e01b815290519192506000916001600160a01b038416916318160ddd916004808301926020929190829003018186803b1580156102a757600080fd5b505afa1580156102bb573d6000803e3d6000fd5b505050506040513d60208110156102d157600080fd5b505160408051631c2e50c160e11b815290519192506000916001600160a01b038c169163385ca18291600480830192602092919082900301818787803b15801561031a57600080fd5b505af115801561032e573d6000803e3d6000fd5b505050506040513d602081101561034457600080fd5b5051905061035685898684868c61050a565b9a9950505050505050505050565b60008061037084610477565b90506000846001600160a01b03166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b1580156103ad57600080fd5b505afa1580156103c1573d6000803e3d6000fd5b505050506040513d60208110156103d757600080fd5b505190506103e6828583610443565b95945050505050565b600061015162989680610410633c33608061040a86886105c9565b9061062b565b90610685565b6000610151670de0b6b3a764000061041061043e61043887633b9aca006105c9565b866106c7565b61083e565b6000610171610469600a6104636402540be40061041061043e89896106c7565b906105c9565b61046360026104638861085a565b6000806000836001600160a01b0316630902f1ac6040518163ffffffff1660e01b815260040160606040518083038186803b1580156104b557600080fd5b505afa1580156104c9573d6000803e3d6000fd5b505050506040513d60608110156104df57600080fd5b5080516020909101516001600160701b039182169350169050610171633b9aca0061041084846105c9565b600080610518888888610443565b905060006105268686610416565b9050600061053482866103ef565b905061055c606461054d61054886856106c7565b6108c4565b6001600160701b031690610685565b604080518c8152602081018c90528082018b9052606081018a90526080810189905260a0810188905260c0810183905290519195507f3a269f8b7a14b50e5e96327a1e2888aa70caf27d3fe04d3d47b401e8e78489e1919081900360e00190a15050509695505050505050565b6000826105d857506000610625565b828202828482816105e557fe5b04146106225760405162461bcd60e51b8152600401808060200182810382526021815260200180610aec6021913960400191505060405180910390fd5b90505b92915050565b600082820183811015610622576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b600061015183836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f0000000000008152506108d4565b6106cf610ab3565b6000821161070e5760405162461bcd60e51b8152600401808060200182810382526026815260200180610ac66026913960400191505060405180910390fd5b826107285750604080516020810190915260008152610625565b71ffffffffffffffffffffffffffffffffffff83116107cf57600082607085901b8161075057fe5b0490506001600160e01b038111156107af576040805162461bcd60e51b815260206004820152601e60248201527f4669786564506f696e743a3a6672616374696f6e3a206f766572666c6f770000604482015290519081900360640190fd5b6040518060200160405280826001600160e01b0316815250915050610625565b60006107e084600160701b85610976565b90506001600160e01b038111156107af576040805162461bcd60e51b815260206004820152601e60248201527f4669786564506f696e743a3a6672616374696f6e3a206f766572666c6f770000604482015290519081900360640190fd5b80516612725dd1d243ab6001600160e01b03909116045b919050565b600060038211156108b6575080600061087e610877836002610685565b600161062b565b90505b818110156108b0578091506108a96108a261089c8584610685565b8361062b565b6002610685565b9050610881565b50610855565b811561085557506001919050565b5160701c6001600160701b031690565b600081836109605760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561092557818101518382015260200161090d565b50505050905090810190601f1680156109525780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b50600083858161096c57fe5b0495945050505050565b60008060006109858686610a16565b915091506000848061099357fe5b8688099050828111156109a7576001820391505b8083039250848210610a00576040805162461bcd60e51b815260206004820152601a60248201527f46756c6c4d6174683a3a6d756c4469763a206f766572666c6f77000000000000604482015290519081900360640190fd5b610a0b838387610a43565b979650505050505050565b6000808060001984860990508385029250828103915082811015610a3b576001820391505b509250929050565b60008181038216808381610a5357fe5b049250808581610a5f57fe5b049450808160000381610a6e57fe5b60028581038087028203028087028203028087028203028087028203028087028203028087028203029586029003909402930460010193909302939093010292915050565b6040805160208101909152600081529056fe4669786564506f696e743a3a6672616374696f6e3a206469766973696f6e206279207a65726f536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f77a26469706673582212208b2e3f9370b97bdd0d2b90b7d0b10fee844ca7b3b277762a7136f40d31914d3064736f6c63430007050033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}